while k <=iter %开始一轮迭代
    
   for i=1:NP %对每个向量个体进行一轮“变异-交叉―选择”过程    
       
       %%%%%================step 1：变异===================================
       
       %%%=====变异准备：首先产生5个不同于i的index标号
       i1=ceil(NP*rand(1));
        while (i1==i)
             i1=ceil(NP*rand(1));
        end
        i2=ceil(NP*rand(1));
        while ((i2==i)||(i2==i1))
             i2=ceil(NP*rand(1));
        end
        i3=ceil(NP*rand(1));
        while ((i3==i)||(i3==i1)||(i3==i2))
             i3=ceil(NP*rand(1));
        end
        i4=ceil(NP*rand(1));
        while ((i4==i)||(i4==i1)||(i4==i2)||(i4==i3))
             i4=ceil(NP*rand(1));
        end
        i5=ceil(NP*rand(1));
        while ((i5==i)||(i5==i1)||(i5==i2)||(i5==i3)||(i5==i4))
             i5=ceil(NP*rand(1));
        end
        %%%====5个标号准备完毕==============================================
        
        F=normrnd(0.5,0.3);     %根据正态分布产生一个控制参数F
        
        %%%%%==================开始变异=====================================
        %由于变异策略有4个（均匀分布），对于每个向量个体都随机挑选其中的一种控制策略
        %每个策略被挑选的概率都是0.25，所以这里利用随机量pp范围【0，1】，
        %来实现这样一个均匀分布的选择，每一次只会选中其中的一种
  
        pp=rand(1);
        
        if pp>0&&pp<=0.25     %表示选中第一个策略
           V(i,:)= W(i1,:) + F.*(W(i2,:)-W(i3,:)); %de/rand/1/bin
           sign=1;
        end 
        if pp>0.25&&pp<=0.5   %表示选中第二个策略
           V(i,:)= W(i,:) + F.*(W(max_index,:)-W(i,:))+ F.*(W(i1,:)-W(i2,:))+F.*(W(i3,:)-W(i4,:)); %de/rand to best/2/bin
           sign=2;
        end 
        if pp>0.5&&pp<=0.75  %表示选中第三个策略
            V(i,:)=W(i1,:)+F.*(W(i2,:)-W(i3,:))+F.*(W(i4,:)-W(i5,:));  %de/rand/2/bin
            sign=3;
        end 
        if pp>0.75&&pp<=1   %表示选中第四个策略
            V(i,:)=W(i,:)+K.*(W(i1,:)-W(i,:))+F.*(W(i2,:)-W(i3,:));  %de/current to rand/1 没有交叉
            sign=4;
        end 
      %%%%=========step1：变异结束=========================================
      
   
      %%%%%=======越界检验,重新取值，因为控制变量有边界限制
       for j=1:n
            if V(i,j)<lb||V(i,j)>ub
              V(i,j)=lb+(ub-lb)*rand;
            end 
       end  
       %%%%%%越界检验结束==================================================
       
       
       %%%%%%==============step 2：交叉====================================
       %%分两类情况，sign=4的时候，无交叉，sign=1,2,3的时候进入交叉环节
       
       %sign=4的交叉
       if sign==4   %第四种模式无交叉环节
           U(i,:)=V(i,:);   
       end 
 
       %由于CR必须取值【0,1】，不能越界（因为它代表的是概率），
       %所以需要用到while循环，排除那些不在【0,1】的CR值
       CR=normrnd(0.5,0.1);
          while CR<=0||CR>1            
          CR=normrnd(0.5,0.1);     %正态分布选择
          end  %直到取到0-1的交叉因子
       
       %前三种模式的交叉
       if sign==1||sign==2||sign==3
        for j=1:n
            jrand=ceil(n*rand(1));  
            if((rand(1)<=CR)||(j==jrand))
                U(i,j)=V(i,j);
            end
        end
       end     
       %%%%======================交叉结束==================================
       
       %%%%%%%==================step 3：选择===============================
       
        fit_=fit_de2(U(i,:),LH0,LD,LH1,x0,xf,f0,h,N); 
        %重新计算向量个体的U（i，：）的适应度函数
        
        if fit_>=fit(i)       %比较
           W_next(i,:) = U(i,:);   %保存适应度函数值更高的试验向量，并完成替换
           fit(i)=fit_;      %替换对应向量的自适应度函数，其他保持不变
        end
        %%%%%%=============选择结束======================================
        
   end % i=NP，种群中的个体全部变异，交叉，选择完毕
   
   %%%%============第一次迭代全部结束，接下来要进行更新=======================
   
   %因为在进化过程中的变异环节需要用到自适应度最好的向量标号max_index，
   %所以需要同时更新这个最大max_index
   [max_fit, max_index]=max(fit);    %间接对fix序列进行排序，输出最高值。
   W=W_next; %更新种群，进入下一次演化过程
   U=W;
   
   %%%%==========更新结束==================================================
   
   
   %%%%===============监控输出===========================================
   %%每隔一定迭代次数时间，输出一下结果，从而把握程序走向，这一小段可忽略不计
    Result=[Result,max_fit];    %显示最高的自适应函数值
    if mod(k,LP)==0                   
         k                %每隔20次显示数据
         max_fit   
         save EMSDE.mat
    end
    %%%%==============监控输出结束========================================
     
    
    
    %%%%%%%%=============准备进入下一次迭代================================
    
    k=k+1; 
end %达到最大迭代次数

%最后求得的W（max_index,:）就是我们要找的最优向量个体


